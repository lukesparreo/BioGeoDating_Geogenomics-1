monitors.append( mnJointConditionalAncestralState(tree=tree,
                                                  ctmc=m_bg,
                                                  type="NaturalNumbers",
                                                  withTips=true,
                                                  withStartStates=true,
                                                  filename=out_fn+".states.log",
                                                  printgen=100) )
monitors.append( mnStochasticCharacterMap(ctmc=m_bg,
                                          filename=out_fn+".stoch.log",
                                          printgen=100) )
# Analysis generations
n_gen = 3000000
    
# Create model
mymodel = model(m_bg, ingroup_older_island)
# Run
mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(n_gen)
# Results in output#### Summarizing output# Go to folder of output once run is completedout_str = "output_informed_normal_migration1" #May need to modify depending on output filenameout_state_fn = out_str + ".states.log"out_tree_fn = out_str + ".tre"out_mcc_fn = out_str + ".mcc.tre"tree_trace = readTreeTrace(file=out_tree_fn, treetype="clock")tree_trace.setBurnin(0.25)n_burn = tree_trace.getBurnin()mcc_tree = mccTree(tree_trace, file=out_mcc_fn)state_trace = readAncestralStateTrace(file=out_state_fn)tree_trace = readAncestralStateTreeTrace(file=out_tree_fn, treetype="clock")anc_tree = ancestralStateTree(tree=mcc_tree,                               ancestral_state_trace_vector=state_trace,                               tree_trace=tree_trace,                               include_start_states=true,                               file=out_str+".ase.tre",                               burnin=n_burn,                               site=1)
q()
alpha <- [10000, 3600, 400]   # Centers of the gamma distributions for epochs
# Beta for gamma distribution
beta <- [1000, 600, 200] # Adjust as needed
# Define the epoch times using a normal prior
for (i in 1:n_epochs) {
  time_max[i] <- time_bounds[i][1]
  time_min[i] <- time_bounds[i][2]
  if (i != n_epochs) {
    epoch_times[i] ~ dnGamma(alpha[i], beta[i])
    epoch_width = time_bounds[i][1] - time_bounds[i][2]
    moves.append( mvSlide(epoch_times[i], delta=epoch_width/2) )
  } else {
    epoch_times[i] <- 0.0
  }
}
print(epoch_times)
      
# Combine the epoch rate matrices and times
# Doesn't work with dnNormal because dnNormal is domain REAL not REALPOS
Q_DEC_epoch := fnEpoch(Q=Q_DEC, times=epoch_times, rates=rep(1, n_epochs))
# Build cladogenetic transition probabilities
clado_event_types <- [ "s", "a" ]
p_sympatry ~ dnUniform(0,1)
p_allopatry := abs(1.0 - p_sympatry)
moves.append( mvSlide(p_sympatry, delta=0.1, weight=2) )
clado_event_probs := simplex(p_sympatry, p_allopatry)
# Note: P_DEC is defined, but you can't view it from print(). Instead check print(type(P_DEC)) and str(P_DEC)
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas,
                         maxRangeSize=max_areas)
                       
# Root frequencies
rf_DEC_raw            <- rep(0, n_states)
rf_DEC_raw[n_areas+1] <- 1  # "Mainland" (original river) is the only possible starting state
rf_DEC                <- simplex(rf_DEC_raw)
    
# The phylogenetic CTMC with cladogenetic events
m_bg ~ dnPhyloCTMCClado(tree=tree,
                           Q=Q_DEC_epoch,
                           cladoProbs=P_DEC,
                           branchRates=rate_bg,
                           rootFrequencies=rf_DEC,
                           type="NaturalNumbers",
                           nSites=1)     
# Attach the range data
m_bg.clamp(dat_range_n)
# Monitor the age of the ingroup
ingroup_clade <- clade("n0",
                       "n1",
                       "n2")
# Set ingroup age
ingroup_age := tmrca(tree, ingroup_clade)
for (i in 1:n_epochs) {
    ingroup_older_island[i] := ifelse(ingroup_age > epoch_times[i], 1, 0)
}
monitors = VectorMonitors()
monitors.append( mnScreen(printgen=100, ingroup_age) )
monitors.append( mnModel(file=out_fn+".model.log", printgen=100) )
monitors.append( mnFile(tree, filename=out_fn+".tre", printgen=100) )
monitors.append( mnJointConditionalAncestralState(tree=tree,
                                                  ctmc=m_bg,
                                                  type="NaturalNumbers",
                                                  withTips=true,
                                                  withStartStates=true,
                                                  filename=out_fn+".states.log",
                                                  printgen=100) )
monitors.append( mnStochasticCharacterMap(ctmc=m_bg,
                                          filename=out_fn+".stoch.log",
                                          printgen=100) )
# Analysis generations
n_gen = 3000000
    
# Create model
mymodel = model(m_bg, ingroup_older_island)
# Run
mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(n_gen)# Results in output#### Summarizing output# Go to folder of output once run is completedout_str = "output_informed_normal_migration2" #May need to modify depending on output filenameout_state_fn = out_str + ".states.log"out_tree_fn = out_str + ".tre"out_mcc_fn = out_str + ".mcc.tre"tree_trace = readTreeTrace(file=out_tree_fn, treetype="clock")tree_trace.setBurnin(0.25)n_burn = tree_trace.getBurnin()mcc_tree = mccTree(tree_trace, file=out_mcc_fn)state_trace = readAncestralStateTrace(file=out_state_fn)tree_trace = readAncestralStateTreeTrace(file=out_tree_fn, treetype="clock")anc_tree = ancestralStateTree(tree=mcc_tree,                               ancestral_state_trace_vector=state_trace,                               tree_trace=tree_trace,                               include_start_states=true,                               file=out_str+".ase.tre",                               burnin=n_burn,                               site=1)
q)=
q()
