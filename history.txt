                          maxRangeSize=max_areas)
}
            
# build the epoch times
for (i in 1:n_epochs) {
  time_max[i] <- time_bounds[i][1]
  time_min[i] <- time_bounds[i][2]
  if (i != n_epochs) {
    epoch_times[i] ~ dnUniform(time_min[i], time_max[i])
    epoch_width = time_bounds[i][1] - time_bounds[i][2]
    moves.append( mvSlide(epoch_times[i], delta=epoch_width/2) )
  } else {
    epoch_times[i] <- 0.0
  }
}
                           
# combine the epoch rate matrices and times
Q_DEC_epoch := fnEpoch(Q=Q_DEC, times=epoch_times, rates=rep(1, n_epochs))
# build cladogenetic transition probabilities
clado_event_types <- [ "s", "a" ]
p_sympatry ~ dnUniform(0,1)
p_allopatry := abs(1.0 - p_sympatry)
moves.append( mvSlide(p_sympatry, delta=0.1, weight=2) )
clado_event_probs := simplex(p_sympatry, p_allopatry)
# warning: P_DEC is defined, but you can't view it from print(). Instead check print(type(P_DEC)) and str(P_DEC)
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas,
                         maxRangeSize=max_areas)
                       
# root frequencies
rf_DEC_raw            <- rep(0, n_states)
rf_DEC_raw[n_areas+1] <- 1  # "Mainland" (original river) is the only possible starting state
rf_DEC                <- simplex(rf_DEC_raw)
    
# the phylogenetic CTMC with cladogenetic events
m_bg ~ dnPhyloCTMCClado(tree=tree,
                           Q=Q_DEC_epoch,
                           cladoProbs=P_DEC,
                           branchRates=rate_bg,
                           rootFrequencies=rf_DEC,
                           type="NaturalNumbers",
                           nSites=1)     
# attach the range data
m_bg.clamp(dat_range_n)
# Monitors
# monitor the age of the ingroup
ingroup_clade <- clade("n0",
                       "n1",
                       "n2")
# I also tried to fix the error by removing n2 from the ingroup clade and it did not fix anything
# Set ingroup age
ingroup_age := tmrca(tree, ingroup_clade)
#is there error here? I actually don't think so, I tried manually setting the root age to a single value (50mya) and the same errors occured downtstream. I might just be getting nan because the root age is a uniform distribution between 0 and 100 MYA.
#> print(ingroup_age)
#nan
#The fact that branchLength(i) returns valid numbers but nodeAge(i) returns nan suggests that the tree might not have node ages properly assigned. This could happen if the tree was read in a way that doesn't retain age information.
#> for (i in 1:tree_init.nnodes()) {
#+     print(tree_init.nodeAge(i))
#+ }
#nan
for (i in 1:n_epochs) {
    ingroup_older_island[i] := ifelse(ingroup_age > epoch_times[i], 1, 0)
}
monitors = VectorMonitors()
monitors.append( mnScreen(printgen=100, ingroup_age) )
monitors.append( mnModel(file=out_fn+".model.log", printgen=100) )
monitors.append( mnFile(tree, filename=out_fn+".tre", printgen=100) )
monitors.append( mnJointConditionalAncestralState(tree=tree,
                                                  ctmc=m_bg,
                                                  type="NaturalNumbers",
                                                  withTips=true,
                                                  withStartStates=true,
                                                  filename=out_fn+".states.log",
                                                  printgen=100) )
monitors.append( mnStochasticCharacterMap(ctmc=m_bg,
                                          filename=out_fn+".stoch.log",
                                          printgen=100) )
# Create model
mymodel = model(m_bg, ingroup_older_island)
# Run
mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(n_gen)
out_str = "output/simulationoutput"
out_state_fn = out_str + ".states.log"
out_tree_fn = out_str + ".tre"
out_mcc_fn = out_str + ".mcc.tre"
tree_trace = readTreeTrace(file=out_tree_fn, treetype="clock")
tree_trace.setBurnin(0.25)
n_burn = tree_trace.getBurnin()
mcc_tree = mccTree(tree_trace, file=out_mcc_fn)
state_trace = readAncestralStateTrace(file=out_state_fn)
tree_trace = readAncestralStateTreeTrace(file=out_tree_fn, treetype="clock")
anc_tree = ancestralStateTree(tree=mcc_tree,
                              ancestral_state_trace_vector=state_trace,
                              tree_trace=tree_trace,
                              include_start_states=true,
                              file=out_str+".ase.tre",
                              burnin=n_burn,
                              site=1)
