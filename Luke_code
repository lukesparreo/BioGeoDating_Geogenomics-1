###PHYLOGENY SIMULATION python
#create ABC tree with 1mya split and 3mya split as a newick file, we will use this tree to create a "fake" biogeography divergence analysis
###Phylogeny simulation plus sequence generation (generates for n=60, select 1 randomly from each population):
###Still working on refining

# general setup
# conda activate msprime-env
# python
import msprime
import matplotlib.pyplot as plt
import demesdraw

# Define the demographic model
demography = msprime.Demography()
demography.add_population(name="A", initial_size=50)
demography.add_population(name="B", initial_size=50)
demography.add_population(name="C", initial_size=100)
demography.add_population(name="AB", initial_size=100)
demography.add_population(name="ABC", initial_size=200)
demography.add_population_split(time=1000000, derived=["A", "B"], ancestral="AB")
demography.add_population_split(time=3000000, derived=["AB", "C"], ancestral="ABC")

# Simulate tree sequence
ts = msprime.sim_ancestry(samples={"A": 10, "B": 10, "C": 10}, 
                          demography=demography, 
                          sequence_length=10000,  #Adjust to a higher length if computationally feasbile in later steps
                          recombination_rate=4.8e-8)

# Define the mutation rate and GTR model parameters
mutation_rate = 1e-8
relative_rates = [6.22, 7.41, 4.26, 5.29, 6.54, 7.33]  #GTR relative rates NEED TO CHANGE for realism (find a study)
equilibrium_frequencies = [0.25, 0.25, 0.25, 0.25]  #A, C, G, T frequencies

# Apply GTR mutations to the tree sequence
ts = msprime.sim_mutations(
    ts,
    rate=mutation_rate,
    model=msprime.GTR(relative_rates=relative_rates, equilibrium_frequencies=equilibrium_frequencies)
)

# Function to get MRCA for each population
def get_population_mrca(ts, pop_name):
    # Find the population ID from metadata
    pop_id = next((i.id for i in ts.populations() if i.metadata["name"] == pop_name), None)
    
    if pop_id is None:
        raise ValueError(f"Population {pop_name} not found in tree sequence.")
    
    # Get sample nodes for this population
    sample_nodes = [n for n in ts.samples() if ts.node(n).population == pop_id]
    
    if len(sample_nodes) < 2:
        raise ValueError(f"Not enough samples for population {pop_name} to compute MRCA.")

    # Compute MRCA
    return ts.first().mrca(*sample_nodes)

# Get MRCA nodes for A, B, and C
pop_mrcas = {}
for pop in ["A", "B", "C"]:
    try:
        pop_mrcas[pop] = get_population_mrca(ts, pop)
    except ValueError as e:
        print(e)

# Compute MRCA for AB (between A and B) and ABC (between AB and C)
tree = ts.first()
try:
    pop_mrcas["AB"] = tree.mrca(pop_mrcas["A"], pop_mrcas["B"])
    pop_mrcas["ABC"] = tree.mrca(pop_mrcas["AB"], pop_mrcas["C"])
except KeyError as e:
    print(f"Error computing MRCA: {e}")

print("Population MRCAs:", pop_mrcas)

# Extract divergence times for populations
divergence_times = {pop: ts.node(mrca).time for pop, mrca in pop_mrcas.items()}
print("Divergence times:", divergence_times)

# Get population-level Newick tree
pop_newick = tree.as_newick(root=pop_mrcas["ABC"])
print("Population-Level Newick Tree:", pop_newick)

# Simplify the tree sequence to retain only species-level structure
simplified_ts = ts.simplify(samples=[pop_mrcas["A"], pop_mrcas["B"], pop_mrcas["C"]], keep_input_roots=True)

# Get the first tree from the simplified tree sequence
collapsed_tree = simplified_ts.first()

# Convert to Newick format
collapsed_newick = collapsed_tree.as_newick()
print("Species-Level Newick Tree:", collapsed_newick)

# Save the Newick tree to file
with open("collapsed_newick.tre", "w") as f:
    f.write(collapsed_newick)

# Write the full Nexus format sequence data
with open("simulated_sequences.nex", "w") as nexus_file:
    ts.write_nexus(nexus_file)

# Select n1, n31, and n51 explicitly
simplified_ts_single = ts.simplify(samples=[1, 31, 51])

# Write the reduced dataset to another Nexus file
with open("simulated_sequences_single.nex", "w") as nexus_file:
    simplified_ts_single.write_nexus(nexus_file)

# Draw demographic model
fig, ax = plt.subplots(figsize=(6, 4))
demesdraw.tubes(demography.to_demes(), ax=ax)
plt.show()

print("Simulated sequence data has been written to:")
print("- Full dataset: 'simulated_sequences.nex'")
print("- Single-individual dataset: 'simulated_sequences_single.nex'")

###IN REVBAYES, BEGIN ANALYSIS
#created CONNECTIVITY MATRICES for 3 epochs
#created DISTANCE MATRIX
#created TIMES MATRICES defining when barriers appeared (5 different models of our estimations)
#created RANGE nexus file
#created MOLECULAR SIMULATION

###putting the model together
#general setup
#conda activate revbayesenv
#rb
#leave rb with quit()

# Read in files
range_fn = "simulated.range.nex"
mol_fn = "simulated_sequences_single.nex"
tree_fn = "collapsed_newick.tre"
out_fn = "output/simulationoutput"
times_fn = "simulated.times.awarerelaxed.txt"
dist_fn = "simulated.distances.txt"

# Read in matrices
#geo_fn = "/simulated."
#times_fn = geo_fn + ".times.*.txt"
#dist_fn = geo_fn + ".distances.txt"

# Analysis helper variables
n_gen = 25000

# Read in molecular alignment
dat_mol = readDiscreteCharacterData(mol_fn)

# Read in species ranges
dat_range_01 = readDiscreteCharacterData(range_fn)
# Compute the number of ranges when ranges may only be one or two areas in size
n_areas <- dat_range_01.nchar()
max_areas <- 2
n_states <- 0
for (k in 0:max_areas) n_states += choose(n_areas, k)
#format
dat_range_n = formatDiscreteCharacterData(dat_range_01, "DEC", n_states)

# Record list of ranges to a file
state_desc = dat_range_n.getStateDescriptions()
state_desc_str = "state,range\n"
for (i in 1:state_desc.size())
{
    state_desc_str += (i-1) + "," + state_desc[i] + "\n"
}
write(state_desc_str, file=out_fn+".state_labels.txt")

# Read the minimum and maximum ages of the island complexes (are we doing this ?)
time_bounds <- readDataDelimitedFile(file=times_fn, delimiter=" ")
n_epochs <- time_bounds.size()

# Read in connectivity matrices
for (i in 1:n_epochs) {
  epoch_fn[i] = "simulated.connectivity." + i + ".txt"
  connectivity[i] <- readDataDelimitedFile(file=epoch_fn[i], delimiter=" ")
}

# Read the distances
distances <- readDataDelimitedFile(file=dist_fn, delimiter=" ")

# Read the tree file
tree_init = readTrees(tree_fn)[1]
# And record information about tree file
taxa = tree_init.taxa()
n_taxa = taxa.size()
n_branches = 2 * n_taxa - 2

# Model for tree
# Get the root age
root_age ~ dnUniform(0, 1000)
moves = VectorMoves()
moves.append( mvScale(root_age, weight=5) )

# Assign the proportion of sampled taxa (we have a non-uniform sampling scheme, but this should suffice).
rho <- 3/3

# Assign birth/death priors
birth ~ dnExp(10)
moves.append( mvScale(birth, weight=2) )
death ~ dnExp(10)
moves.append( mvScale(death, weight=2) )

# Initiate tree
tree ~ dnBDP(lambda=birth, mu=death, rho=rho, rootAge=root_age, taxa=taxa)

# Topology and branch lengths
moves.append( mvNNI(tree, weight=n_branches/2) )
moves.append( mvFNPR(tree, weight=n_branches/8) )
moves.append( mvNodeTimeSlideUniform(tree, weight=n_branches/2) )
moves.append( mvSubtreeScale(tree, weight=n_branches/8) )
moves.append( mvTreeScale(tree, root_age, weight=n_branches/8) )

# Provide starting tree for biogeographic model 
tree.setValue(tree_init)
root_age.setValue(tree_init.rootAge())

# Creating molecular model


