###working method that makes both species and population level trees
#create ABC tree with 1mya split and 3mya split as a newick file, we will use this tree to create a "fake" biogeography divergence analysis
#general setup
#conda activate msprime-env
#python
import msprime
import tskit
import matplotlib.pyplot as plt
import demesdraw

# Define the demographic model
demography = msprime.Demography()
demography.add_population(name="A", initial_size=50)
demography.add_population(name="B", initial_size=50)
demography.add_population(name="C", initial_size=100)
demography.add_population(name="AB", initial_size=100)
demography.add_population(name="ABC", initial_size=200)
demography.add_population_split(time=1_000_000, derived=["A", "B"], ancestral="AB")
demography.add_population_split(time=3_000_000, derived=["AB", "C"], ancestral="ABC")

# Simulate tree sequence
ts = msprime.sim_ancestry(samples={"A": 10, "B": 10, "C": 10}, 
                          demography=demography, 
                          sequence_length=1e6, 
                          recombination_rate=1e-8)
ts = msprime.sim_mutations(ts, rate=1e-8, model="jc69")  # Add genetic mutations

# Function to get MRCA for each population
def get_population_mrca(ts, pop_name):
    # Find the population ID from metadata
    pop_id = next((i.id for i in ts.populations() if i.metadata["name"] == pop_name), None)
    
    if pop_id is None:
        raise ValueError(f"Population {pop_name} not found in tree sequence.")
    
    # Get sample nodes for this population
    sample_nodes = [n for n in ts.samples() if ts.node(n).population == pop_id]
    
    if len(sample_nodes) < 2:
        raise ValueError(f"Not enough samples for population {pop_name} to compute MRCA.")

    # Compute MRCA
    return ts.first().mrca(*sample_nodes)

# Get MRCA nodes for A, B, and C
pop_mrcas = {}
for pop in ["A", "B", "C"]:
    try:
        pop_mrcas[pop] = get_population_mrca(ts, pop)
    except ValueError as e:
        print(e)

# Compute MRCA for AB (between A and B) and ABC (between AB and C)
tree = ts.first()
try:
    pop_mrcas["AB"] = tree.mrca(pop_mrcas["A"], pop_mrcas["B"])
    pop_mrcas["ABC"] = tree.mrca(pop_mrcas["AB"], pop_mrcas["C"])
except KeyError as e:
    print(f"Error computing MRCA: {e}")

print("Population MRCAs:", pop_mrcas)

# Extract divergence times for populations
divergence_times = {pop: ts.node(mrca).time for pop, mrca in pop_mrcas.items()}
print("Divergence times:", divergence_times)

# Get population-level Newick tree
pop_newick = tree.as_newick(root=pop_mrcas["ABC"])
print("Population-Level Newick Tree:", pop_newick)

# Simplify the tree sequence to retain only species-level structure
simplified_ts = ts.simplify(samples=[pop_mrcas["A"], pop_mrcas["B"], pop_mrcas["C"]], keep_input_roots=True)

# Get the first tree from the simplified tree sequence
collapsed_tree = simplified_ts.first()

# Convert to Newick format
collapsed_newick = collapsed_tree.as_newick()
print("Species-Level Newick Tree:", collapsed_newick)

# Draw demographic model
fig, ax = plt.subplots(figsize=(6, 4))
demesdraw.tubes(demography.to_demes(), ax=ax)
plt.show()

###


###older version of this method that only creates population tree
#importing packages
import msprime
import matplotlib.pyplot as plt
import demesdraw
import numpy as np

#define the changes to demographic size from event
demography = msprime.Demography()
demography.add_population(name="A", initial_size=50)
demography.add_population(name="B", initial_size=50)
demography.add_population(name="C", initial_size=100)
demography.add_population(name="AB", initial_size=100)
demography.add_population(name="ABC", initial_size=200)
demography.add_population_split(time=1000000, derived=["A", "B"], ancestral="AB")
demography.add_population_split(time=3000000, derived=["AB", "C"], ancestral="ABC")
demography

#tree sequence, with recombination occuring at angiosperm levels and about 1 million base pairs
ts = msprime.sim_ancestry(samples={"A": 10, "B": 10, "C":10}, demography=demography, sequence_length=1e6, recombination_rate=1e-8)
ts = msprime.sim_mutations(ts, rate=1e-8, model="jc69") #add genetic mutations

#drawing demographic model
fig, ax = plt.subplots(figsize=(6,4))
demesdraw.tubes(demography.to_demes(), ax=ax)
plt.show()

#displaying divergence times in the tree
tree = ts.first()
newick_tree = tree.newick()
print(newick_tree)

#find the divergence times
divergence_times = [tree.time(root) for root in tree.roots]
print(divergence_times)
#should be near 3,000,000
#we could adjust for generation time here where T_generations = T_divergence / [number of years in genereation]. But because Podostemaceae are annuals we will keep it as is

#code in to plot in r: 
#library(ape)
#tree<-ape::read.tree(text= "add_newick_here")
#plot(tree)
#or save this to a .nwk file via nano and open in R for visualization


###alternative method not working
import msprime

# Define demographic model with populations and their splits
demography = msprime.Demography()
demography.add_population(name="Ancestral", initial_size=20000)
demography.add_population(name="Pop1", initial_size=10000)
demography.add_population(name="Pop2", initial_size=5000)
demography.add_population(name="Pop3", initial_size=8000)

# Define multiple split events
demography.add_population_split(time=5000, derived=["Pop1", "Pop2"], ancestral="Ancestral")
demography.add_population_split(time=3000, derived=["Pop3"], ancestral="Pop2")

# Function to reconstruct a population tree from msprime.Demography
def demography_to_newick(demography):
    """
    Convert an msprime demographic model into a Newick tree of populations.
    """
    # Dictionary to track relationships
    pop_tree = {pop.name: pop.name for pop in demography.populations}  

    # Get split events (sorted from oldest to most recent)
    split_events = []
    for event in demography.events:
        if isinstance(event, msprime.DemographyEvent):  # Catching split events
            if hasattr(event, "derived") and hasattr(event, "ancestral") and hasattr(event, "time"):
                split_events.append((event.derived, event.ancestral, event.time))

    # Sort splits by time (oldest first)
    split_events.sort(key=lambda x: x[2])

    # Build the Newick tree
    for derived, ancestral, time in split_events:
        if isinstance(derived, list):  # Multiple derived populations
            subtree = "(" + ",".join(f"{pop_tree[pop]}:{time}" for pop in derived) + f")"
        else:  # Single population split
            subtree = f"({pop_tree[derived]}:{time})"
        pop_tree[ancestral] = subtree  # Replace ancestral with updated subtree

    # Return the final tree structure
    return pop_tree["Ancestral"] + ";"

# Convert to Newick format
pop_newick_tree = demography_to_newick(demography)
print(pop_newick_tree)


###old demographic model (DO NOT USE)
# Define a demographic model with populations and a split history
#demography = msprime.Demography()
#demography.add_population(name="Ancestral", initial_size=100)
#demography.add_population(name="Pop1", initial_size=100)
#demography.add_population(name="Pop2", initial_size=100)

# Define the population split event
#demography.add_population_split(time=1000000, derived=["Pop1"], ancestral="Pop2")
#demography.add_population_split(time=3000000, derived=["Pop1", "Pop2"], ancestral="Ancestral")
#set conditions for mock data, with split occuring 3mya

#define rate of migration before barrier and set migration after split to 0
#demography.set_migration_rate(source="A", dest="B", rate=migration_rate)
#demography.set_migration_rate(source="B", dest="A", rate=migration_rate)
#demography.set_migration_rate(source="C", dest="AB", rate=migration_rate)
#demography.set_migration_rate(source="AB", dest="C", rate=migration_rate)
#demography.add_migration_rate_change(time=T_divergence, rate=0)


###additional method #working on still, the tree has no branch lenghts?
import numpy as np
import dendropy

#create simulation with specifications
def simulate_barrier_phylogeny(num_species=30, divergence_time=3000000, barrier_effect=0.5):
   tree = dendropy.Tree()
   root = tree.seed_node
   for i in range(num_species):
      new_node = root.new_child(taxon=dendropy.Taxon(label=f"Species_{i+1}"))
   for node in tree.leaf_nodes():
      if np.random.rand() < barrier_effect:
         new_child = node.new_child(taxon=dendropy.Taxon(label=f"{node.taxon.label}_Diverged"))
         new_child.edge.length = divergence_time
   return tree

#simulate tree
simulated_tree = simulate_barrier_phylogeny(num_species=30, divergence_time=3000000, barrier_effect=0.7)

#view tree after converting to Newick
tree_newick = simulated_tree.as_string(schema="newick")
print(tree_newick)
