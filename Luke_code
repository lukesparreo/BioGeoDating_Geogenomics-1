###PHYLOGENY SIMULATION python
#create ABC tree with 1mya split and 3mya split as a newick file, we will use this tree to create a "fake" biogeography divergence analysis
#general setup
#conda activate msprime-env
#python
import msprime
import matplotlib.pyplot as plt
import demesdraw

# Define the demographic model
demography = msprime.Demography()
demography.add_population(name="A", initial_size=50)
demography.add_population(name="B", initial_size=50)
demography.add_population(name="C", initial_size=100)
demography.add_population(name="AB", initial_size=100)
demography.add_population(name="ABC", initial_size=200)
demography.add_population_split(time=1_000_000, derived=["A", "B"], ancestral="AB")
demography.add_population_split(time=3_000_000, derived=["AB", "C"], ancestral="ABC")

# Simulate tree sequence
ts = msprime.sim_ancestry(samples={"A": 10, "B": 10, "C": 10}, 
                          demography=demography, 
                          sequence_length=10000, #may want to change to 1e6 if computationally feasible
                          recombination_rate=4.8e-8)

# Define the mutation rate for the lineages, we want to use the GTR model, which is not part of msprime, so we will use tskit and have to define our rate matrix
mutation_rate = 1e-8

# Define the GTR model parameters (relative rates and equilibrium frequencies)
relative_rates = [6.22, 7.41, 4.26, 5.29, 6.54, 7.33]  # 6 relative rates for A→C, A→G, A→T, C→G, C→T, G→T from https://watermark.silverchair.com/mbev_17_08_1146.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAA2YwggNiBgkqhkiG9w0BBwagggNTMIIDTwIBADCCA0gGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQM4nEJW1pwB3JV3-7IAgEQgIIDGcLr7PCh6yZjzPiZIRe9tqh8K77C4w5w6MFYyQfffC3M4LPnHWVV9wYOjTL3ODEatp-67LEEmX824qaOUd2JqMYDkZYV_IPp3CVxVldDB48phSVPyezmFPtSxGw3n-T5Nzof3ZGgH-lkxpPzZIz0Uz90THVFrSoI-Gcf27ogTNXKxpjIfv1zKaCcqzA3JhW6noS8OXcDKpgibBlhdU1RM2yRnVNQ1I8MYjze-STOwWJw5lb3zPuUSuzoAyckke3FyBfT7Nps-rdZB7zp6XPnR7ydEr1M8DSgGF5tGlGlBHk5NlTgAV0dUV9JvE2t4DOuLj6MnLBCRcRdnOiu1WzI0EwxU1iJcXrmTw6FyjEq-5Pz6_oQBvn0Xfcu0ZWtrprwPnML_J3vsgem525JC1wZO_g4Jhh-kw3_pVZXoNS1W4mxiaUci8fFw7wxtKhZikmSCteEEEAIQucs60y8emVrq_kdwxbXMPAFYlehjjCuGHh5im9uOBfGC8peVP8yIrb410__Sl44BQk8GLcDaZ94GVYHNw8ockhydrSzk01nWRV1oBgpxnd2_Bv2aHNzSQ2EHXoGcc-UjXVjnQQUrvrogw_eXx3QPwWLB0s20KgHJg-LkNnlMW7IBMyr5HYRjNGHA0eGC-ZrVbw6H37fIL6lBbleSbGdxnhIDBa3m7NE7FrBxz6DXW4780KcTNHLDMIeVc58wB7dlKPCb3Skl5zK9qzBx-P79lLxZvx02gAO5YIkCUtuSsvlMAQcQ1z1B8IunuBusvn60Ol4RDGR9TeUpqDW6RFrhg4UlXkWVtmWFrQI49cL4j59y4-pp9zNzM0qeZKajgY9WuXUa94-3xq2BoYeS7wHKwn0VuazG9Tl84WFeJcocGc78PyUHG7_VGV34t7V8z-p0cKgFlkWMbkzb9Z1Ly0_CCHDHHFvxUDGQFmoifaglVu-3YUCduuyNGuBZyP9kr6RnT83JUVgvq4LHvgZJz3nkmSkF2COeX-YBGOPpKRDQlcYdNJmOdsA45j9eQ8_xEFGQs75kvvCxVy4RYhpcWsUfAODQ7w
equilibrium_frequencies = [0.25, 0.25, 0.25, 0.25]  # Equal base frequencies (A, C, G, T)

# Apply GTR mutations using msprime.sim_mutations
ts = msprime.sim_mutations(
    ts,
    rate=mutation_rate,
    model=msprime.GTR(relative_rates=relative_rates, equilibrium_frequencies=equilibrium_frequencies)
)

# Function to get MRCA for each population
def get_population_mrca(ts, pop_name):
    # Find the population ID from metadata
    pop_id = next((i.id for i in ts.populations() if i.metadata["name"] == pop_name), None)
    
    if pop_id is None:
        raise ValueError(f"Population {pop_name} not found in tree sequence.")
    
    # Get sample nodes for this population
    sample_nodes = [n for n in ts.samples() if ts.node(n).population == pop_id]
    
    if len(sample_nodes) < 2:
        raise ValueError(f"Not enough samples for population {pop_name} to compute MRCA.")

    # Compute MRCA
    return ts.first().mrca(*sample_nodes)

# Get MRCA nodes for A, B, and C
pop_mrcas = {}
for pop in ["A", "B", "C"]:
    try:
        pop_mrcas[pop] = get_population_mrca(ts, pop)
    except ValueError as e:
        print(e)

# Compute MRCA for AB (between A and B) and ABC (between AB and C)
tree = ts.first()
try:
    pop_mrcas["AB"] = tree.mrca(pop_mrcas["A"], pop_mrcas["B"])
    pop_mrcas["ABC"] = tree.mrca(pop_mrcas["AB"], pop_mrcas["C"])
except KeyError as e:
    print(f"Error computing MRCA: {e}")

print("Population MRCAs:", pop_mrcas)

# Extract divergence times for populations
divergence_times = {pop: ts.node(mrca).time for pop, mrca in pop_mrcas.items()}
print("Divergence times:", divergence_times)

# Get population-level Newick tree
pop_newick = tree.as_newick(root=pop_mrcas["ABC"])
print("Population-Level Newick Tree:", pop_newick)

# Simplify the tree sequence to retain only species-level structure
simplified_ts = ts.simplify(samples=[pop_mrcas["A"], pop_mrcas["B"], pop_mrcas["C"]], keep_input_roots=True)

# Get the first tree from the simplified tree sequence
collapsed_tree = simplified_ts.first()

# Convert to Newick format
collapsed_newick = collapsed_tree.as_newick()
print("Species-Level Newick Tree:", collapsed_newick)
with open("collapsed_newick.tre", "w") as f:
  f.write(collapsed_newick)

# Draw demographic model
fig, ax = plt.subplots(figsize=(6, 4))
demesdraw.tubes(demography.to_demes(), ax=ax)
plt.show()

#to leave msprime environment use conda deactivate

###create CONNECTIVITY MATRICES for 3 epochs
###create DISTANCE MATRIX
###create TIMES MATRIX defining when barriers appeared
###

###MOLECULAR SIMULATION revbayes
#general setup
#conda activate revbayesenv
#rb
#leave rb with quit()

#read the msprime simulated tree
tree_fn = readTrees("collapsed_newick.tre")[1]
print(tree_fn)

#read in range and molecular nexus files
range_fn =
mol_fn = 

#read in matrices
geo_fn = "/simulated."
times_fn = geo_fn + ".times.*.txt"
dist_fn = geo_fn + ".distances.txt"

#output
out_fn = "output/simulationoutput"

#analysis helper variables ?
n_gen = 25000 

#read in molecular alignment
dat_mol = readDiscreteCharacterData(mol_fn) #not going to work need to define molecular simulation

#read in species ranges
dat_range_01 = readDiscreteCharacterData(range_fn)

